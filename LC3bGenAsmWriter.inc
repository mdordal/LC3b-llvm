//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void LC3bAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    268435467U,	// ADDCCri
    268435467U,	// ADDCCrr
    268435474U,	// ADDXri
    268435474U,	// ADDXrr
    268435480U,	// ADDri
    268435480U,	// ADDrr
    570425373U,	// ADJCALLSTACKDOWN
    570425392U,	// ADJCALLSTACKUP
    268435521U,	// ANDNri
    268435521U,	// ANDNrr
    268435527U,	// ANDri
    268435527U,	// ANDrr
    570425420U,	// BA
    805306448U,	// BCOND
    570425426U,	// CALL
    335544408U,	// FABSD
    335544415U,	// FABSS
    268435558U,	// FADDD
    268435565U,	// FADDS
    805306484U,	// FBCOND
    637534327U,	// FCMPD
    637534334U,	// FCMPS
    268435589U,	// FDIVD
    268435596U,	// FDIVS
    335544467U,	// FDTOI
    335544474U,	// FDTOS
    335544481U,	// FITOD
    335544488U,	// FITOS
    175U,	// FLUSHW
    335544502U,	// FMOVD
    1207959741U,	// FMOVD_FCC
    1241514173U,	// FMOVD_ICC
    335544515U,	// FMOVS
    1207959754U,	// FMOVS_FCC
    1241514186U,	// FMOVS_ICC
    268435664U,	// FMULD
    268435671U,	// FMULS
    335544542U,	// FNEGD
    335544549U,	// FNEGS
    268435692U,	// FSMULD
    335544564U,	// FSQRTD
    335544572U,	// FSQRTS
    335544580U,	// FSTOD
    335544587U,	// FSTOI
    268435730U,	// FSUBD
    268435737U,	// FSUBS
    335544608U,	// FpABSD
    335544617U,	// FpMOVD
    335544626U,	// FpNEGD
    1342177595U,	// GETPCX
    1610612818U,	// JMPLri
    1610612818U,	// JMPLrr
    1879048508U,	// LDDFri
    1879048508U,	// LDDFrr
    1879048514U,	// LDFri
    1879048514U,	// LDFrr
    1879048519U,	// LDSBri
    1879048519U,	// LDSBrr
    1879048526U,	// LDSHri
    1879048526U,	// LDSHrr
    1879048533U,	// LDUBri
    1879048533U,	// LDUBrr
    1879048540U,	// LDUHri
    1879048540U,	// LDUHrr
    1879048514U,	// LDri
    1879048514U,	// LDrr
    2147483672U,	// LEA_ADDri
    1207959907U,	// MOVFCCri
    1207959907U,	// MOVFCCrr
    1241514339U,	// MOVICCri
    1241514339U,	// MOVICCrr
    359U,	// NOP
    268435819U,	// ORNri
    268435819U,	// ORNrr
    268435824U,	// ORri
    268435824U,	// ORrr
    335544692U,	// POPCrr
    570425722U,	// RDY
    268435842U,	// RESTOREri
    268435842U,	// RESTORErr
    570425739U,	// RET
    570425748U,	// RETL
    268435869U,	// SAVEri
    268435869U,	// SAVErr
    268435875U,	// SDIVri
    268435875U,	// SDIVrr
    425U,	// SELECT_CC_DFP_FCC
    453U,	// SELECT_CC_DFP_ICC
    481U,	// SELECT_CC_FP_FCC
    508U,	// SELECT_CC_FP_ICC
    535U,	// SELECT_CC_Int_FCC
    563U,	// SELECT_CC_Int_ICC
    335544911U,	// SETHIi
    268436054U,	// SLLri
    268436054U,	// SLLrr
    268436059U,	// SMULri
    268436059U,	// SMULrr
    268436065U,	// SRAri
    268436065U,	// SRArr
    268436070U,	// SRLri
    268436070U,	// SRLrr
    2415919723U,	// STBri
    2415919723U,	// STBrr
    2415919728U,	// STDFri
    2415919733U,	// STDFrr
    2415919739U,	// STFri
    2415919739U,	// STFrr
    2415919743U,	// STHri
    2415919743U,	// STHrr
    2415919739U,	// STri
    2415919739U,	// STrr
    268436100U,	// SUBCCri
    268436100U,	// SUBCCrr
    268436107U,	// SUBXCCrr
    268436115U,	// SUBXri
    268436115U,	// SUBXrr
    268436121U,	// SUBri
    268436121U,	// SUBrr
    670U,	// TA3
    268436131U,	// UDIVri
    268436131U,	// UDIVrr
    268436137U,	// UMULri
    268436137U,	// UMULrr
    570426031U,	// UNIMP
    654312118U,	// WRYri
    654312118U,	// WRYrr
    268436154U,	// XNORri
    268436154U,	// XNORrr
    268436160U,	// XORri
    268436160U,	// XORrr
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000addcc \000addx \000add \000!ADJCALLSTACKDOWN \000!ADJCALLS"
    "TACKUP \000andn \000and \000ba \000b\000call \000fabsd \000fabss \000fa"
    "ddd \000fadds \000fb\000fcmpd \000fcmps \000fdivd \000fdivs \000fdtoi \000"
    "fdtos \000fitod \000fitos \000flushw\000fmovd \000fmovd\000fmovs \000fm"
    "ovs\000fmuld \000fmuls \000fnegd \000fnegs \000fsmuld \000fsqrtd \000fs"
    "qrts \000fstod \000fstoi \000fsubd \000fsubs \000!FpABSD \000!FpMOVD \000"
    "!FpNEGD \000\000ldd [\000ld [\000ldsb [\000ldsh [\000ldub [\000lduh [\000"
    "mov\000nop\000orn \000or \000popc \000rd %y, \000restore \000jmp %i7+\000"
    "jmp %o7+\000save \000sdiv \000; SELECT_CC_DFP_FCC PSEUDO!\000; SELECT_C"
    "C_DFP_ICC PSEUDO!\000; SELECT_CC_FP_FCC PSEUDO!\000; SELECT_CC_FP_ICC P"
    "SEUDO!\000; SELECT_CC_Int_FCC PSEUDO!\000; SELECT_CC_Int_ICC PSEUDO!\000"
    "sethi \000sll \000smul \000sra \000srl \000stb \000std \000std  \000st "
    "\000sth \000subcc \000subxcc \000subx \000sub \000ta 3\000udiv \000umul"
    " \000unimp \000wr \000xnor \000xor \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 1023)-1;


  // Fragment 0 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, FLUSHW, NOP, SELECT_CC_DFP_FCC, SELECT_CC_DFP_ICC, SELECT_C...
    return;
    break;
  case 1:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 1, O); 
    O << ", "; 
    break;
  case 2:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, FCMPD, FCMPS, RDY, RET, RE...
    printOperand(MI, 0, O); 
    break;
  case 3:
    // BCOND, FBCOND
    printCCOperand(MI, 1, O); 
    O << ' '; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // FMOVD_FCC, FMOVD_ICC, FMOVS_FCC, FMOVS_ICC, MOVFCCri, MOVFCCrr, MOVICC...
    printCCOperand(MI, 3, O); 
    break;
  case 5:
    // GETPCX
    printGetPCX(MI, 0, O); 
    return;
    break;
  case 6:
    // JMPLri, JMPLrr
    printMemOperand(MI, 0, O); 
    return;
    break;
  case 7:
    // LDDFri, LDDFrr, LDFri, LDFrr, LDSBri, LDSBrr, LDSHri, LDSHrr, LDUBri, ...
    printMemOperand(MI, 1, O); 
    O << "], "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 8:
    // LEA_ADDri
    printMemOperand(MI, 1, O, "arith"); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 9:
    // STBri, STBrr, STDFri, STDFrr, STFri, STFrr, STHri, STHrr, STri, STrr
    printOperand(MI, 2, O); 
    O << ", ["; 
    printMemOperand(MI, 0, O); 
    O << ']'; 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 25) & 7) {
  default:   // unreachable.
  case 0:
    // ADDCCri, ADDCCrr, ADDXri, ADDXrr, ADDri, ADDrr, ANDNri, ANDNrr, ANDri,...
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, BA, CALL, RDY, RET, RETL, UNIMP
    return;
    break;
  case 2:
    // FABSD, FABSS, FDTOI, FDTOS, FITOD, FITOS, FMOVD, FMOVS, FNEGD, FNEGS, ...
    printOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // FCMPD, FCMPS, WRYri, WRYrr
    O << ", "; 
    printOperand(MI, 1, O); 
    break;
  case 4:
    // FMOVD_FCC, FMOVS_FCC, MOVFCCri, MOVFCCrr
    O << " %fcc0, "; 
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  case 5:
    // FMOVD_ICC, FMOVS_ICC, MOVICCri, MOVICCrr
    O << " %icc, "; 
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 24) & 1) {
    // WRYri, WRYrr
    O << ", %y"; 
    return;
  } else {
    // FCMPD, FCMPS
    O << "\n\tnop"; 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *LC3bAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 84 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 9, 12, 15, 19, 23, 27, 31, 35, 39, 43, 47, 
    51, 55, 59, 62, 3, 65, 6, 68, 9, 71, 12, 74, 15, 77, 
    19, 81, 23, 85, 27, 89, 31, 93, 35, 97, 39, 101, 43, 105, 
    47, 109, 51, 113, 55, 117, 121, 125, 128, 131, 134, 137, 140, 143, 
    146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 180, 183, 186, 
    189, 192, 195, 198, 201, 204, 207, 210, 213, 216, 219, 222, 225, 0
  };

  const char *AsmStrs =
    "F0\000F2\000F4\000F6\000F8\000F10\000F12\000F14\000F16\000F18\000F20\000"
    "F22\000F24\000F26\000F28\000F30\000F0\000F1\000F3\000F5\000F7\000F9\000"
    "F11\000F13\000F15\000F17\000F19\000F21\000F23\000F25\000F27\000F29\000F"
    "31\000FCC\000G0\000G1\000G2\000G3\000G4\000G5\000G6\000G7\000I0\000I1\000"
    "I2\000I3\000I4\000I5\000FP\000I7\000ICC\000L0\000L1\000L2\000L3\000L4\000"
    "L5\000L6\000L7\000O0\000O1\000O2\000O3\000O4\000O5\000SP\000O7\000Y\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *LC3bAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 144 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 159, 167, 174, 181, 187, 193, 210, 225, 232, 239, 245, 251, 254, 
    260, 265, 271, 277, 283, 289, 296, 302, 308, 314, 320, 326, 332, 338, 
    344, 351, 357, 367, 377, 383, 393, 403, 409, 415, 421, 427, 434, 441, 
    448, 454, 460, 466, 472, 479, 486, 493, 500, 507, 514, 521, 528, 534, 
    540, 547, 554, 561, 568, 575, 582, 589, 596, 601, 606, 616, 625, 634, 
    643, 652, 656, 662, 668, 673, 678, 685, 689, 699, 709, 713, 718, 725, 
    732, 739, 746, 764, 782, 799, 816, 834, 852, 859, 865, 871, 878, 885, 
    891, 897, 903, 909, 915, 921, 928, 935, 941, 947, 953, 959, 964, 969, 
    977, 985, 994, 1001, 1008, 1014, 1020, 1024, 1031, 1038, 1045, 1052, 1058, 1064, 
    1070, 1077, 1084, 1090, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADDCCri\000ADDCCrr\000"
    "ADDXri\000ADDXrr\000ADDri\000ADDrr\000ADJCALLSTACKDOWN\000ADJCALLSTACKU"
    "P\000ANDNri\000ANDNrr\000ANDri\000ANDrr\000BA\000BCOND\000CALL\000FABSD"
    "\000FABSS\000FADDD\000FADDS\000FBCOND\000FCMPD\000FCMPS\000FDIVD\000FDI"
    "VS\000FDTOI\000FDTOS\000FITOD\000FITOS\000FLUSHW\000FMOVD\000FMOVD_FCC\000"
    "FMOVD_ICC\000FMOVS\000FMOVS_FCC\000FMOVS_ICC\000FMULD\000FMULS\000FNEGD"
    "\000FNEGS\000FSMULD\000FSQRTD\000FSQRTS\000FSTOD\000FSTOI\000FSUBD\000F"
    "SUBS\000FpABSD\000FpMOVD\000FpNEGD\000GETPCX\000JMPLri\000JMPLrr\000LDD"
    "Fri\000LDDFrr\000LDFri\000LDFrr\000LDSBri\000LDSBrr\000LDSHri\000LDSHrr"
    "\000LDUBri\000LDUBrr\000LDUHri\000LDUHrr\000LDri\000LDrr\000LEA_ADDri\000"
    "MOVFCCri\000MOVFCCrr\000MOVICCri\000MOVICCrr\000NOP\000ORNri\000ORNrr\000"
    "ORri\000ORrr\000POPCrr\000RDY\000RESTOREri\000RESTORErr\000RET\000RETL\000"
    "SAVEri\000SAVErr\000SDIVri\000SDIVrr\000SELECT_CC_DFP_FCC\000SELECT_CC_"
    "DFP_ICC\000SELECT_CC_FP_FCC\000SELECT_CC_FP_ICC\000SELECT_CC_Int_FCC\000"
    "SELECT_CC_Int_ICC\000SETHIi\000SLLri\000SLLrr\000SMULri\000SMULrr\000SR"
    "Ari\000SRArr\000SRLri\000SRLrr\000STBri\000STBrr\000STDFri\000STDFrr\000"
    "STFri\000STFrr\000STHri\000STHrr\000STri\000STrr\000SUBCCri\000SUBCCrr\000"
    "SUBXCCrr\000SUBXri\000SUBXrr\000SUBri\000SUBrr\000TA3\000UDIVri\000UDIV"
    "rr\000UMULri\000UMULrr\000UNIMP\000WRYri\000WRYrr\000XNORri\000XNORrr\000"
    "XORri\000XORrr\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif

#ifdef PRINT_ALIAS_INSTR
#undef PRINT_ALIAS_INSTR

namespace { // Register classes
  enum RegClass {
    RC_DFPRegs,
    RC_FPRegs,
    RC_IntRegs
  };
} // end anonymous namespace

static bool regIsInRegisterClass(unsigned RegClass, unsigned Reg) {
  switch (RegClass) {
  default: break;
  case RC_DFPRegs:
    switch (Reg) {
    default: break;
    case SP::D0:
    case SP::D1:
    case SP::D2:
    case SP::D3:
    case SP::D4:
    case SP::D5:
    case SP::D6:
    case SP::D7:
    case SP::D8:
    case SP::D9:
    case SP::D10:
    case SP::D11:
    case SP::D12:
    case SP::D13:
    case SP::D14:
    case SP::D15:
      return true;
    }
    break;
  case RC_FPRegs:
    switch (Reg) {
    default: break;
    case SP::F0:
    case SP::F1:
    case SP::F2:
    case SP::F3:
    case SP::F4:
    case SP::F5:
    case SP::F6:
    case SP::F7:
    case SP::F8:
    case SP::F9:
    case SP::F10:
    case SP::F11:
    case SP::F12:
    case SP::F13:
    case SP::F14:
    case SP::F15:
    case SP::F16:
    case SP::F17:
    case SP::F18:
    case SP::F19:
    case SP::F20:
    case SP::F21:
    case SP::F22:
    case SP::F23:
    case SP::F24:
    case SP::F25:
    case SP::F26:
    case SP::F27:
    case SP::F28:
    case SP::F29:
    case SP::F30:
    case SP::F31:
      return true;
    }
    break;
  case RC_IntRegs:
    switch (Reg) {
    default: break;
    case SP::L0:
    case SP::L1:
    case SP::L2:
    case SP::L3:
    case SP::L4:
    case SP::L5:
    case SP::L6:
    case SP::L7:
    case SP::I0:
    case SP::I1:
    case SP::I2:
    case SP::I3:
    case SP::I4:
    case SP::I5:
    case SP::O0:
    case SP::O1:
    case SP::O2:
    case SP::O3:
    case SP::O4:
    case SP::O5:
    case SP::O7:
    case SP::G1:
    case SP::G2:
    case SP::G3:
    case SP::G4:
    case SP::O6:
    case SP::I6:
    case SP::I7:
    case SP::G0:
    case SP::G5:
    case SP::G6:
    case SP::G7:
      return true;
    }
    break;
  }

  return false;
}

namespace {

// Flags for subtarget features that participate in alias instruction matching.
enum SubtargetFeatureFlag {
  Feature_None = 0
};

} // end anonymous namespace

unsigned LC3bAsmPrinter::
ComputeAvailableFeatures(const LC3bSubtarget *Subtarget) const {
  unsigned Features = 0;
  return Features;
}

bool LC3bAsmPrinter::printAliasInstr(const MachineInstr *MI, raw_ostream &OS) {
  return false;
}

#endif // PRINT_ALIAS_INSTR
